
/*
描述狗 行为：吼叫
描述狼 行为：吼叫
发现他们之间有共性，可以进行向上抽取
当然是抽取他们的所属共性类型：犬科
犬科这类事物：都具备吼叫行为，但是具体怎么叫，是不确定的，是由具体的子类来明确的。
这时在描述犬科时，发现了有些功能不具体，这些不具体的功能，需要在类中标识出来，通过Java关键字abstract（抽象）
定义了抽象函数的类也必须被abstract关键字修饰，被abstract关键字修饰的类是抽象类。

抽象类：在描述事物时，没有足够的信息描述一个事物，这时该事物就是抽象事物。

*/

/*
【抽象类的特点】
1、抽象类和抽象方法都需要被abstract修饰。
   抽象方法一定要定义在抽象类中。
2、抽象类不可以创建实例。原因：调用抽象方法没有意义。
3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以实例化。
   否则该子类还是一个抽象类。

之所以继承，更多的是在思想，是面对共性类型操作会更简单。
*/

/*

【细节问题】
1、抽象类一定是个父类？
   是的。因为不断抽取而来的。

2、抽象类是否有构造函数？
   有，虽然不能给自己的对象初始化，但是可以给自己的子类对象初始化。
   
   抽象类和一般类的异同点：
   相同：
		1、它们都是用来描述事物的。
		2、它们之中都可以定义属性和行为。
   不同：
		1、一般类可以具体的描述事物。
		   抽象类描述事物的信息不具体。
		2、抽象类中可以定义一个成员：抽象函数。
		3、一般类可以创建对象，而抽象类不能创建对象。
	
3、抽象类中是否可以不定义抽象方法？
   是可以的。那这个抽象类的存在到底有什么意义呢？仅仅是不让该类创建对象。

4、抽象关键字abstract不可以和哪些关键字共存？
   1、final：final修饰完的类是最终类，没有子类。而抽象类必须有子类。冲突了。
   2、private：抽象方法需要被覆盖。但加上私有，其子类甚至都看不到了，无法使用。
   3、static：静态则随着类的加载而加载，直接能被类名调用。而被抽象类直接调用，是没有意义的。

*/



abstract class 犬科
{
	abstract void 吼叫();//抽象函数。需要abstract修饰，并分号;结束。
}

//代码体现。
class Dog extends 犬科
{
	void 吼叫()
	{
		System.out.println("汪汪汪汪");
	}
}

class Wolf extends 犬科
{
	void 吼叫()
	{
		System.out.println("嗷嗷嗷嗷");
	}
}

class AbstractDemo 
{
	public static void main(String[] args) 
	{
		System.out.println("Hello World!");
	}
}
