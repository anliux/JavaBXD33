## 多线程的细节：

1、面试题：sleep方法和wait方法的异同：
	相同点：可以让线程处于冻结状态。
	不同点：
		1、sleep必须指定时间。
		   wait可以指定时间，也可以不指定时间
		2、sleep时间到，线程处于临时阻塞或者运行
		   wait如果没有时间，必须通过notify或notifyAll唤醒。
		3、sleep不一定非要定义在同步中（sleep是静态方法，前面不用标志锁）
		   wait必须定义在同步中
		4、<关键> 
		   都定义在同步中时：
		   线程执行到sleep时，不会释放锁
		   线程执行到wait时，会释放锁

扩展题：
synchronized(obj)
{
	wait();//0,1,2
	code..
}

synchronized(obj)
{
	notifyAll();//3
	code...
}

这一段代码没有线程安全问题。
当3把0,1,2都唤醒时，同步中有0123一共4个线程。
但是：012只有执行资格，处于临时阻塞状态，因为锁obj还在3手里，即使执行权切出去了，也执行不了
当3走完，（隐式地）把锁释放之后，假设012其一得到执行权，然后继续执行，到释放，这中间是没有线程安全问题的。
因为有obj锁，当锁在某线程手里时，别人是进不来的。



==========================================
2、线程如何停止呢？
	stop方法过时了，看其描述发现，有其他解决方案。
	线程结束：就是让线程任务代码执行完，run方法结束。
	run方法咋结束呢？
	run方法中通常都定义循环，只要控制循环，就哦了。

	StopThreadDemo.java -- 停止线程方法的演示

	注意：万一线程在任务中处于了冻结状态，那么它还能去判断标记吗？不能。
	咋办？通过查阅API文档中stop方法的描述，发现提供了一个解决方法：
		如果目标线程等待很长时间，则应使用 interrupt 方法来中断该等待。
	所谓的中断：并不是停止线程。
	interrupt的功能：将线程的冻结状态清除，让线程恢复到运行状态（让线程重新具备CPU的执行资格）
	因为是强制性的，所以会有异常发生，可以在catch中捕获异常，在异常处理中改变标记，让循环结束，让run方法结束。



============================================
3、守护线程：后台线程，一般创建的都是前台线程。
	例如：前台的演员和后台的灯光师等工作人员，前台表演完毕，后台自动结束。
	标记：setDaemon 例如：t2.setDaemon(true);  t2.start();
	前台后台线程运行时都是一样的，获取CPU的执行权执行。
	只有结束的时候有不同。
	    前台线程要通过run方法结束，线程结束。
	    后台线程也可以通过run方法结束，线程结束。还有另一种情况。
	        当进程中所有的前台线程都结束了，这时无论后台线程处于什么样的状态，都会结束。从而进程会结束。
	进程结束依赖的都是前台线程。
	应用：需要开启线程去运行数据，而只要进程结束，不管它什么情况都要跟着结束，这时可标记为守护线程。



==============================================
注：toString() -- 返回该线程的字符串表示形式，包括线程名称、优先级和线程组。

4、线程的优先级：用数字表示，1-10，数字越大，优先级越高。
	默认的初始优先级是5。
	数字接近的，优先级也接近。
	最明显的三个优先级：1,5,10
	设置优先级：setPriority(int newPriority) -- 更改线程的优先级
		字段摘要-静态直接用 MAX-最大，MIN-最小，NORM-默认
		setPriority(Thread.MAX_PRIORITY);

5、线程组：ThreadGroup：可以通过Thread的构造函数明确新线程对象所属的线程组。
	线程组的好处：可以对多个同组线程进行统一的操作。
	默认都属于main线程。
	设置线程名字：
		Thread t1 = new Thread(d, "旺财");
		Thread t2 = new Thread(d, "小强");



====================================================
6、join和yield



=====================================================
7、线程的匿名内部类





