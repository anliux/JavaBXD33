/*
需求：为了描述事物更准确，发现事物对应的很多对象一创建时，就有了一些初始化的数据。
这在类中该如何完成？

通过Java中的另一个小技术完成：就是构造函数。对象本身就是构造出来的。
构造时，需要做一些动作，这些应该定义在函数内。

构造函数有什么用呢？可以对对象进行初始化。

构造函数怎么在代码中体现呢？
1，没有返回值类型，因为构造对象，创建完就结束，不需要结果。void也不要写，因为要区别于一般函数。
2，构造函数名称和类名一致。
3，没有具体的返回值。

接下来，按照以上三点，在Person类中定义一个构造函数。
对象一创建就具备了姓名。


发现了问题：
没有学习构造函数时，对象也创建出来了。那么该对象是否有被构造呢？或者说是否有调用构造函数呢？

是的。必须调用！！

class Person
{
	//Person(){}//默认的空参数构造函数。
}

main()
{
	Person p = new Person();//这就是已经调用了Person类中的空参数的构造函数。
							//类中有定义该构造函数吗？有的。只要定义一个类，（接下一行）
							//（接上一行）该类中就默认有一个空参数的构造函数，是编译器编译时添加到class文件中的。
							//注意：如果在类中自定义了构造函数，那么默认的空参数构造函数编译器就不添加了。
							//原理：没有定义对象的初始化过程，编译器会添加一个默认的初始化过程。
							//		如果定义了指定的对象初始化过程，默认的就不添加了。(所以构造函数不能重载？？)
}



构造函数-细节：
1、一个类中可以有多个构造函数，它们的存在是以重载的形式体现的。
2、构造函数中也是有return语句的，用于结束或提前结束初始化功能。
	Person(int a)
	{
		if(a<0)
			return;
		age = a;
	}
3、构造函数是否能被私有private修饰(私有只能修饰成员，不能修饰局部)
   能。作用：其他程序无法创建该类的对象。但在本类里可以创建。
	class Person
	{
		private Person(){}
	}

	main()
	{
		Person p = new Person();//创建对象无法初始化。
	}

构造函数与一般函数的区别？
1、写法不一样。但这个不重要，写熟练就好。
2、运行上有差别。对象一创建就会调用对应的构造函数。
   一般方法是对象创建后，才会调用所需的一般函数。
   
   问：有了构造函数初始化姓名，那么还需要setName方法吗？
   答：需要。因为对象创建后，如果需要对数据进行修改，可以通过set完成。
3、构造函数在对象创建时，仅调用一次（初始化动作只做一次，而且先执行）。
   一般方法可以被对象调用多次。
	class Person
	{
		//Person(){} //默认的空参数
		void Person(){} //这个不是构造函数，是一般函数。但开发不要这么写，因为一般函数名称都有规范。
	}

	main()
	{
		Person p = new Person();//编译可以通过。有默认的空参数。
	}


*/



class Person
{
	//属性：姓名，年龄
	private String name;
	private int age;

	//3个构造函数

	//一初始化，既没有姓名，也没有年龄
	Person()
	{
	
	}

	//定义构造函数，对象一创建就具备姓名。
	Person(String n)
	{
		//将接收到的值赋值给对象的name
		name = n;
	}

	//一初始化既有姓名，又有年龄
	Person(String n, int a)
	{
		name = n;
		age = a;
	}

	//行为。
	public void speak()
	{
		System.out.println("name="+name+",age="+age);
	}
}


class PersonDemo2 
{
	public static void main(String[] args) 
	{
		//Person p1 = new Person();//这样会报错，不能重载……
		Person p = new Person("lisi");
			//Person p = new Person();//小括号内不写内容会报错，显示需要String，找到没有参数
			//对象创建时，必须会调用对应的构造函数，因为对象需要初始化。
		
		Person p = new Person("wangwu",23); //有了新的其他构造函数之后这样写也是合法的。
		p.speak();
	}
}
